# 🧭 ISUCON 学習ノート

## 🎯 全体ゴール
ISUCON出場・完走・スコアアップ  
→ ボトルネック特定から改善までを一人で完遂できるようになる。

---

## 📘 知識マップ進捗

| カテゴリ | 学習状況 | 学ぶ主題（ISUCONで求められる観点） | メモ |
|-----------|------------|------------------------------------|------|
| **OS / Linux** | ⚪ 未着手 | CPU・メモリ・I/O、プロセス・スレッド監視（top, dstat） | |
| **Webサーバ** | ⚪ 未着手 | Nginx設定、Keep-Alive、リバースプロキシ、静的キャッシュ | |
| **アプリケーション** | 🔵 習得中 | Express/Rust最適化、非同期処理、キャッシュ戦略 | キャッシュは重い処理（10ms以上）で効果発揮、アムダールの法則で効果判定 |
| **データベース** | ⚪ 未着手 | MySQL INDEX、N+1対策、EXPLAINによる分析 | |
| **ベンチ / 計測** | 🔵 習得中 | autocannon・wrkなどでの負荷試験・再測定 | processingTimeMs追加、キャッシュあり/なし比較で効果可視化 |
| **観測 / 可視化** | 🟢 開始 | p95/p99レイテンシ、slow query log、メトリクス分析 | 処理時間をレスポンスに含めて可視化、統計エンドポイント実装 |
| **環境構築** | ⚪ 未着手 | Docker/Composeで再現環境を作る | |
| **チーム運用** | ⚪ 未着手 | コード・設定共有、再現性担保 | |
| **メンタルモデル** | 🟢 開始 | 計測→改善→再測定のループ思考 | ボトルネック特定→改善→計測のループ実践、効果の数値確認が重要 |

---

## 🚀 実践タスクログ

### Day 1（2025-11-02）
- **テーマ:** Express APIサーバー作成とベンチマーク実行
- **アクション:** ExpressでAPIサーバーを作成、autocannonでベンチマーク実行
- **結果:** 
- **気づき:** node.js上で簡単にAPIサーバーが作成できる。autocannonという負荷テストツールがある。k6などより、npm install数が多いらしい

### Day 2（2025-11-03）
- **テーマ:** キャッシュ戦略の効果検証と最適化
- **アクション:** 
  - メモリキャッシュの実装
  - 重い処理をシミュレートしてキャッシュ効果を可視化
  - キャッシュあり/なしでのパフォーマンス比較
- **結果:** 
  - キャッシュなし: 80 req/s, 122.81ms latency, 20ms processing
  - キャッシュあり: 3,119 req/s, 2.68ms latency, 0ms processing
  - **約39倍の性能向上**を達成
- **気づき:** キャッシュは重い処理がある時に効果を発揮する。処理が軽すぎると効果が見えない。

---

## 💡 学びのメモ

### キャッシュ最適化の原則：アムダールの法則

#### 問題：なぜ最初のコードではキャッシュ効果が感じられなかったか？

**以前のコード（軽量処理）**
- 処理内容: 単純な配列生成のみ `[{ id: 1, name: "Apple" }, ...]`
- 処理時間: 数マイクロ秒（ほぼ0ms）
- ベンチマーク結果: 4,402 req/s, 1.60ms latency
- **キャッシュ効果: ほとんど見られない**

**改善後のコード（重い処理あり）**
- 処理内容: CPU集約処理（10-20ms）+ I/O遅延（5-15ms） + 大きなデータセット（100アイテム）
- 処理時間: 合計15-35ms
- ベンチマーク結果:
  - キャッシュなし: 80 req/s, 122.81ms latency, 20ms processing
  - キャッシュあり: 3,119 req/s, 2.68ms latency, 0ms processing
- **キャッシュ効果: 約39倍の性能向上**

#### 理由の分析

1. **ボトルネックの位置が違った**
   - 以前: ボトルネックが**ネットワーク/Expressフレームワークのオーバーヘッド**（約1.6ms）
   - 改善後: ボトルネックが**アプリケーションの処理時間**（約20ms）
   - → キャッシュは処理時間を削減するが、フレームワークオーバーヘッドは削減できない

2. **アムダールの法則**
   ```
   全体の性能向上 = 1 / ((1 - P) + P/S)
   P = 最適化する部分の割合
   S = その部分の速度向上率
   ```
   - 以前: P ≈ 0.1%（処理時間が全体の0.1%程度）
   - 改善後: P ≈ 95%（処理時間が全体の95%）
   - → **最適化する部分の割合が大きいほど、効果が目に見える**

3. **コストバランス**
   - キャッシュチェックのコスト: 約0.01ms（if文 + メモリアクセス）
   - 以前の処理コスト: 約0.001ms（配列生成）
   - 改善後の処理コスト: 約20ms（重い処理）
   - → **処理コストが高いほど、キャッシュの相対的な効果が大きい**

#### 実践的な教訓

✅ **キャッシュが効果的な場面**
- DBクエリ、外部API呼び出し、重い計算処理がある時
- 処理時間が10ms以上かかる処理
- 同じデータが頻繁にアクセスされる

❌ **キャッシュの効果が薄い場面**
- 処理が非常に軽量（1ms未満）な時
- フレームワーク/ネットワークオーバーヘッドが支配的な時
- データが毎回異なる（キャッシュヒット率が低い）

#### ISUCONでの応用

1. **ボトルネックの特定が重要**
   - プロファイリングで時間がかかっている部分を特定
   - その部分が最適化対象になる

2. **キャッシュ戦略の選択**
   - 重い処理（DB、外部API）→ キャッシュが有効
   - 軽い処理 → キャッシュオーバーヘッドが目立つ可能性

3. **計測の重要性**
   - 感覚ではなく数値で効果を確認
   - `processingTimeMs`などの指標を追加して可視化 

### 初回リクエストのパフォーマンス問題とウォームアップ戦略

#### なぜ初回リクエストは遅くなりがちか？

**コールドスタート問題の原因**

1. **JITコンパイラの最適化（V8エンジン）**
   - 初回実行時、コードが解釈実行される（遅い）
   - 頻繁に実行されるコード（hot path）が検出されるまで時間がかかる
   - 最適化コンパイルが完了するまで、処理速度が低下
   - **影響**: 初回リクエストで数ms〜数十msの遅延が発生

2. **依存関係のロードと初期化**
   - モジュールのインポート、クラスの初期化
   - データベース接続プールの確立
   - 外部ライブラリの初期化処理
   - **影響**: 初回のみ数十ms〜数百msの遅延

3. **メモリの初期化とアロケーション**
   - ヒープメモリの初期確保
   - ガベージコレクタの調整（世代管理の確立）
   - キャッシュバッファの初期化
   - **影響**: メモリアクセスパターンの最適化が完了するまでの遅延

4. **キャッシュが空の状態**
   - メモリキャッシュが空で、重い処理を実行する必要がある
   - データベースクエリ結果のキャッシュが無い
   - 静的リソースのキャッシュが無い
   - **影響**: 初回のみ重い処理（DB、外部API）を実行するため遅い

5. **ネットワーク接続の確立**
   - TCP接続の確立（3-way handshake）
   - TLSハンドシェイク（HTTPSの場合）
   - Keep-Alive接続が確立されていない
   - **影響**: 初回リクエストで10-100ms程度の追加遅延

#### 実測例（現在のコード）

- **初回リクエスト**: `source: "fresh"`, `processingTimeMs: 20ms`（重い処理実行）
- **2回目以降**: `source: "cache"`, `processingTimeMs: 0ms`（キャッシュヒット）

**ベンチマークでの影響**
- 初回リクエストが計測に含まれると、平均レイテンシが押し上げられる
- 特に短い計測期間では、初回の遅延が全体に影響しやすい

#### ウォームアップ（キャッシュ予熱）戦略

**1. サーバー起動時の自動ウォームアップ**

```javascript
// サーバー起動時にキャッシュを事前ロード
app.listen(port, async () => {
  console.log(`Server running at http://localhost:${port}`);
  // 起動時にキャッシュをウォームアップ
  await warmupCache();
  console.log('Cache warmed up');
});
```

**メリット**:
- ベンチマーク開始時点でキャッシュが既に準備済み
- 初回リクエストが最速で処理される
- JITコンパイラの最適化も同時に促進

**デメリット**:
- サーバー起動時間が少し増える
- 起動時にリソースを使用

**2. ヘルスチェック経由でのウォームアップ**

ヘルスチェックエンドポイントから自動的にウォームアップリクエストを送信：

```javascript
app.get('/health', async (req, res) => {
  // ヘルスチェックのついでにキャッシュをウォームアップ
  if (!itemsCache) {
    await generateItems(); // バックグラウンドで実行
  }
  res.json({ status: 'ok' });
});
```

**3. バックグラウンドタスクでの継続的なプリロード**

定期的にアクセス頻度の高いデータをプリロード：

```javascript
// 定期的にキャッシュを更新
setInterval(async () => {
  if (itemsCache) {
    // キャッシュをバックグラウンドで更新
    const items = await generateItems();
    itemsCache = items;
  }
}, 60000); // 60秒ごと
```

**4. ベンチマーク実行前のウォームアップ**

ベンチマークスクリプト側で、本計測前にウォームアップリクエストを送信（既に実装済み）：

```javascript
// bench-logs.mjs のウォームアップ部分
await run({
  url,
  connections,
  duration: Math.min(3, Math.max(1, Math.floor(duration / 3))),
});
```

**5. 複数回のウォームアップリクエスト**

初回リクエストだけでなく、複数回リクエストしてJIT最適化も促進：

```javascript
async function warmupCache() {
  // 複数回リクエストしてJIT最適化も促進
  for (let i = 0; i < 5; i++) {
    await fetch('http://localhost:3000/items');
  }
}
```

#### ISUCONでの実践ポイント

1. **サーバー再起動前後の差を理解**
   - 再起動直後はコールドスタート状態
   - ベンチマークは通常、サーバー起動後に実行される
   - → ウォームアップが重要

2. **計測の公平性**
   - 初回リクエストを除外するか、十分なウォームアップを実施
   - ベンチマークツールのウォームアップ機能を活用

3. **本番環境での考慮**
   - デプロイ直後はパフォーマンスが低下する可能性
   - ヘルスチェックでウォームアップを兼ねる設計

4. **キャッシュの戦略的配置**
   - サーバー起動時に頻繁にアクセスされるデータを事前ロード
   - 起動時間とパフォーマンスのトレードオフを検討
